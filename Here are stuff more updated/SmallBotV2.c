#pragma config(Sensor, dgtl1,  leftSolenoid,   sensorDigitalOut)
#pragma config(Sensor, dgtl2,  rightSolenoid,  sensorDigitalOut)
#pragma config(Sensor, dgtl9,  leftShooterSensor, sensorQuadEncoder)
#pragma config(Sensor, dgtl11, rightShooterSensor, sensorQuadEncoder)
#pragma config(Motor,  port1,           leftDrive,     tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           leftDrive1,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           rightShooter1, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           rightShooter2, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           leftIntake,    tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           rightIntake,   tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           leftShooter1,  tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           leftShooter2,  tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           rightDrive1,   tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          rightDrive,    tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//VEX stuff
#pragma competitionControl(Competition)
#pragma autonomousDuration(60)
#pragma userControlDuration(60)

#include "Vex_Competition_Includes.c"
#include "PID.h"
#define DEADZONE 10
//Mano, na boa, quem sabe o que eh essa porra dessa variavel do nome do motor definida no pragma. Agora todo mundo sabe
//http://robotics.stackexchange.com/questions/751/confused-about-the-variables-in-robotc


//for debug purpose
int potencia_motor_esquerdo, potencia_motor_direito;
int velocidade_motor_esquerdo, velocidade_motor_direito;
int autonTargetSpeed;

void drive();
void intake();
void shooter(MOTOR_PI* motorA, MOTOR_PI* motorB);
task autonShooterControl();

void move(int rightPower, int leftPower, int time);
void setIntake(int power);

int wheelSpeed;
MOTOR_PI motorLeftShooter, motorRightShooter;

/* Pre Auton */
void pre_auton(){
}

/* Autonomous */
task autonomous(){

	bool blueSide = true;
	shooter_MotorInit(&motorLeftShooter, leftShooter1, leftShooter2, leftShooterSensor);
	shooter_MotorInit(&motorRightShooter, rightShooter1, rightShooter2, rightShooterSensor);
	clearAll(actOnSensors);
	startTask(autonShooterControl);
	if(blueSide)
	{
		autonTargetSpeed = 75;

		wait1Msec(1200);
		for(int i = 0; i < 5; i++)
		{
			wait1Msec(2000);
			setIntake(120);
			wait1Msec(500);
			setIntake(0);
		}
	}
	while(true){}

}

/* User Control */
task usercontrol()
{
	shooter_MotorInit(&motorLeftShooter, leftShooter1, leftShooter2, leftShooterSensor);
	shooter_MotorInit(&motorRightShooter, rightShooter1, rightShooter2, rightShooterSensor);
  clearAll(actOnSensors);
	clearTimer(T1);
  clearTimer(T2);
	while(true)
	{
		drive();
		intake();
		shooter(&motorLeftShooter, &motorRightShooter);

		velocidade_motor_esquerdo=motorLeftShooter.speedRead;
		potencia_motor_esquerdo=motorLeftShooter.controller_output;
		velocidade_motor_direito=motorRightShooter.speedRead;
		potencia_motor_direito=motorRightShooter.controller_output;
	}
}



void drive()
{

	if(vexRT[Ch3]>DEADZONE || vexRT[Ch3]<-DEADZONE)
	{
		motor[leftDrive]=vexRT[Ch3];
		motor[leftDrive1]=vexRT[Ch3];
	}
	else
	{
		motor[leftDrive]=0;
		motor[leftDrive1]=0;
	}
	if(vexRT[Ch2]>DEADZONE || vexRT[Ch2]<-DEADZONE)
	{
		motor[rightDrive]=vexRT[Ch2];
		motor[rightDrive1]=vexRT[Ch2];
	}
	else
	{
		motor[rightDrive]=0;
		motor[rightDrive1]=0;
	}
}

void shooter(MOTOR_PI* motorA, MOTOR_PI* motorB)
{
	bool RT8U;
	bool RT8D;
/////////////
	if(vexRT[Btn8U] == 1){
		if(!RT8U) wheelSpeed++;
		RT8U=true;
	}
	else RT8U = false;
///////////////////
	if(vexRT[Btn8R] == 1)
		wheelSpeed = 75;
///////////////
	if(vexRT[Btn8D] == 1){
		if(!RT8D) wheelSpeed--;
		RT8D=true;
	}
	else RT8D = false;
///////////////
	if(vexRT[Btn8L] == 1)
		wheelSpeed = 71;

	if(vexRT[Btn6U] == 1)
	{
		(*motorA).speedSet = wheelSpeed;
		(*motorB).speedSet = wheelSpeed;
	}
	else if(vexRT[Btn6D] == 1)
	{
		(*motorA).speedSet = 0;
		(*motorB).speedSet = 0;
	}
	shooter_Control(motorA, motorB);
}

void intake()
{
	if(vexRT[Btn5U]==1)
	{
		motor[leftIntake] = 120;
		motor[rightIntake] = 120;
	}
	if(vexRT[Btn5D]==1)
	{
		motor[leftIntake] = -120;
		motor[rightIntake] = -120;
  }
	else if (vexRT[Btn5U]!=1 && vexRT[Btn5D]!=1)
	{
		motor[leftIntake] = 0;
		motor[rightIntake] = 0;
	}

}



task autonShooterControl()
{
	while(true)
	{
		motorLeftShooter.speedSet = autonTargetSpeed;
		motorRightShooter.speedSet = autonTargetSpeed;

		shooter_Control(&motorLeftShooter, &motorRightShooter);

		velocidade_motor_esquerdo=motorLeftShooter.speedRead;
		potencia_motor_esquerdo=motorLeftShooter.controller_output;
		velocidade_motor_direito=motorRightShooter.speedRead;
		potencia_motor_direito=motorRightShooter.controller_output;
	}
}

void move(int rightPower, int leftPower, int time)
{
	motor[rightDrive] = rightPower;
	motor[rightDrive1] = rightPower;
	motor[leftDrive] = leftPower;
	motor[leftDrive1] = leftPower;

	time1[T3] = 0;
	while(time1[T3] < time){}
}

void setIntake(int power)
{
 	motor[rightIntake] = power;
 	motor[leftIntake] = power;
}
