#pragma config(Sensor, in1,    lineLeft,       sensorLineFollower)
#pragma config(Sensor, in2,    lineMiddle,     sensorLineFollower)
#pragma config(Sensor, in3,    lineRight,      sensorLineFollower)
#pragma config(Sensor, in7,    lineCheck,      sensorLineFollower)
#pragma config(Sensor, dgtl1,  QEncL,          sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  QEncR,          sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  jumper,         sensorDigitalIn)
#pragma config(Sensor, dgtl7,  DriveQEnc,      sensorQuadEncoder)
#pragma config(Sensor, dgtl9,  touchR,         sensorTouch)
#pragma config(Sensor, dgtl10, touchL,         sensorTouch)
#pragma config(Sensor, dgtl11, sonar,          sensorSONAR_mm)
#pragma config(Motor,  port2,           rightDrive1,   tmotorVex393, openLoop)
#pragma config(Motor,  port3,           leftDrive1,    tmotorVex393, openLoop)
#pragma config(Motor,  port4,           intake1,       tmotorVex393, openLoop)
#pragma config(Motor,  port5,           liftLeft,      tmotorVex393, openLoop)
#pragma config(Motor,  port6,           liftRight,     tmotorVex393, openLoop)
#pragma config(Motor,  port8,           rightDrive2,   tmotorVex393, openLoop)
#pragma config(Motor,  port9,           leftDrive2,    tmotorVex393, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX2)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(60)
#pragma userControlDuration(60)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!

void tank();
void lift();
void intake();
void move_drive(int degrees, int power);




#define deadZone 10
#define speed 120
bool manualLiftMode = false;

void pre_auton()
{
  bStopTasksBetweenModes = true;
}

task autonomous()
{

}

void step1()
{
	move_drive(20, 50);
	take_in_one_cube();
}

void move_drive(int degrees, int power)
{
	bool stopMotorRequest = power == -1 && degrees == -1;
	bool unlimited = degrees == -1 && !stopMotorRequest;
	power = stopMotorRequest ? 0 : power;
	if(unlimited)
	{

	}
	else if (degrees == -1)
	{

	}


}

void karanAutonomous()
{

bool reached = false;
	int lSpeed = 0, rSpeed = 0, multiplier = 1;
	if(SensorValue[jumper] == 1) multiplier = -1;

	while(!reached){
		if(SensorValue[QEncL] < 200 || SensorValue[QEncR] < 200) reached = false;
		else reached = true;

		if(SensorValue[QEncL] < SensorValue[QEncR] + 10 && SensorValue[QEncL] > SensorValue[QEncR] - 10){
				lSpeed = rSpeed = 120;
		}
		else if(SensorValue[QEncL] < SensorValue[QEncR] + 10){
				rSpeed -= 10;
		}
		else if(SensorValue[QEncL] > SensorValue[QEncR] - 10){
				lSpeed -= 10;
		}
		motor[liftLeft] = lSpeed;
		motor[liftRight] = rSpeed;
	}
	motor[liftLeft] = 0;
	motor[liftRight] = 0;

	motor[leftDrive1] = -120;
	motor[rightDrive1] = -120;
	motor[leftDrive2] = -120;
	motor[rightDrive2] = -120;
	wait1Msec(1300);
	motor[leftDrive1] = 0;
	motor[rightDrive1] = 0;
	motor[leftDrive2] = 0;
	motor[rightDrive2] = 0;

	wait1Msec(500);
	motor[leftDrive1] = 120*multiplier;
	motor[rightDrive1] = -120*multiplier;
	motor[leftDrive2] = 120*multiplier;
	motor[rightDrive2] = -120*multiplier;
	wait1Msec(1150);
	motor[leftDrive1] = 0;
	motor[rightDrive1] = 0;
	motor[leftDrive2] = 0;
	motor[rightDrive2] = 0;
	wait1Msec(500);
	motor[leftDrive1] = 120;
	motor[rightDrive1] = 120;
	motor[leftDrive2] = 120;
	motor[rightDrive2] = 120;
	wait1Msec(2000);
	motor[leftDrive1] = 0;
	motor[rightDrive1] = 0;
	motor[leftDrive2] = 0;
	motor[rightDrive2] = 0;

}

task usercontrol()
{
	while (true)
	{
	  lift();
	  if(!manualLiftMode)
	  {
	  	tank();
	  	intake();
	  }
	}
}

void tank()
{
	int Y1 = vexRT[Ch3];
	int Y2 = vexRT[Ch2];
	if(abs(Y1) < deadZone)
	{
		Y1 = 0;
	}
	if(abs(Y2) < deadZone)
	{
		Y2 = 0;
	}
	motor[leftDrive1] = Y1;
	motor[leftDrive2] = Y1;
	motor[rightDrive1] = Y2;
	motor[rightDrive2] = Y2;
}

void lift()
{
	bool liftUp = vexRT[Ch3Xmtr2] > 10;
	bool liftDown = vexRT[Ch3Xmtr2] < -10;

	bool manualLiftLeft = vexRT[Btn5DXmtr2] == 1 && vexRT[Btn5UXmtr2] == 1;
	bool manualLiftRight = vexRT[Btn6DXmtr2] == 1 && vexRT[Btn6UXmtr2] == 1;
	bool manualUp = vexRT[Ch2Xmtr2] > 10;
	bool manualDown = vexRT[Ch2Xmtr2] < -10;
	manualLiftMode = manualLiftLeft || manualLiftRight;
	motor[intake1] = manualLiftMode ? 0 : motor[intake1];

	bool rightEncoderIsGreater = SensorValue[QEncL] + 15 < SensorValue[QEncR];

	bool rightIsDown = SensorValue[touchR] == 1;
	bool leftIsDown = SensorValue[touchL] == 1;

	bool rightSlowDown = liftDown && !rightEncoderIsGreater && !rightIsDown;
	bool leftSlowDown = liftDown && !rightEncoderIsGreater && !leftIsDown;

	int rightLiftPower = liftUp ? 100 : liftDown && rightSlowDown ? -66 : liftDown && leftSlowDown ? -100 : liftDown && !rightIsDown ? -100 : 0;
	int leftLiftPower = liftUp ? 100 : liftDown && leftSlowDown ? -66 : liftDown && rightSlowDown ? -100 : liftDown && !leftIsDown ? -100 : 0;

	rightLiftPower = manualLiftRight && manualUp ? 75 : manualLiftRight && manualDown ? -75 : manualLiftMode ? 0 : rightLiftPower;
	leftLiftPower = manualLiftLeft && manualUp ? 75 : manualLiftLeft && manualDown ? -75 : manualLiftMode ? 0 : leftLiftPower;

	motor[liftRight] = rightLiftPower;
	motor[liftLeft] = leftLiftPower;

	if (rightIsDown)
	{
		SensorValue[QEncR] = 0;
	}
	if(leftIsDown)
	{
		SensorValue[QEncL] = 0;
	}
}

void intake()
{
		int motorpower = (vexRT[Btn6UXmtr2] == 1) ? -100 : (vexRT[Btn6DXmtr2] == 1) ? 100 : 0;
		motor[intake1] = motorpower;
}
