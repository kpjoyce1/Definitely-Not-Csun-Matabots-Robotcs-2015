#pragma config(Sensor, dgtl1,  QEncL,          sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  QEncR,          sensorQuadEncoder)
#pragma config(Sensor, dgtl11, touchR,         sensorTouch)
#pragma config(Sensor, dgtl12, touchL,         sensorTouch)
#pragma config(Motor,  port2,           rightDrive1,   tmotorVex393, openLoop)
#pragma config(Motor,  port3,           leftDrive1,    tmotorVex393, openLoop)
#pragma config(Motor,  port4,           intake1,       tmotorVex393, openLoop)
#pragma config(Motor,  port5,           liftLeft,      tmotorVex393, openLoop)
#pragma config(Motor,  port6,           liftRight,     tmotorVex393, openLoop)
#pragma config(Motor,  port8,           rightDrive2,   tmotorVex393, openLoop)
#pragma config(Motor,  port9,           leftDrive2,    tmotorVex393, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX2)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(60)
#pragma userControlDuration(60)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!

void tank();
void lift();
void intake();





#define deadZone 10
#define speed 120
bool manualLiftMode = false;

void pre_auton()
{
  bStopTasksBetweenModes = true;
}

task autonomous()
{
	AutonomousCodePlaceholderForTesting();  // Remove this function call once you have "real" code.
}


task usercontrol()
{
	while (true)
	{
	  lift();
	  if(!manualLiftMode)
	  {
	  	tank();
	  	intake();
	  }
	}
}

void tank()
{
	int Y1 = vexRT[Ch3];
	int Y2 = vexRT[Ch2];
	if(abs(Y1) < deadZone)
	{
		Y1 = 0;
	}
	if(abs(Y2) < deadZone)
	{
		Y2 = 0;
	}
	motor[leftDrive1] = Y1;
	motor[leftDrive2] = Y1;
	motor[rightDrive1] = Y2;
	motor[rightDrive2] = Y2;
}

void lift()
{
	bool liftUp = vexRT[Btn5U] == 1;
	bool liftDown = vexRT[Btn5D] == 1;

	bool manualLiftLeft = vexRT[Btn5D] == 1 && vexRT[Btn5U] == 1;
	bool manualLiftRight = vexRT[Btn6D] == 1 && vexRT[Btn6U] == 1;
	bool manualUp = vexRT[Ch2] > 10;
	bool manualDown = vexRT[Ch2] < -10;
	manualLiftMode = manualLiftLeft || manualLiftRight;
	motor[intake1] = manualLiftMode ? 0 : motor[intake1];

	bool rightEncoderIsGreater = SensorValue[QEncL] + 15 < SensorValue[QEncR];

	bool rightIsDown = SensorValue[touchR] == 1;
	bool leftIsDown = SensorValue[touchL] == 1;

	bool rightSlowDown = liftDown && !rightEncoderIsGreater && !rightIsDown;
	bool leftSlowDown = liftDown && !rightEncoderIsGreater && !leftIsDown;

	int rightLiftPower = liftUp ? 100 : liftDown && rightSlowDown ? -66 : liftDown && leftSlowDown ? -100 : liftDown && !rightIsDown ? -100 : 0;
	int leftLiftPower = liftUp ? 100 : liftDown && leftSlowDown ? -66 : liftDown && rightSlowDown ? -100 : liftDown && !leftIsDown ? -100 : 0;

	rightLiftPower = manualLiftRight && manualUp ? 75 : manualLiftRight && manualDown ? -75 : manualLiftMode ? 0 : rightLiftPower;
	leftLiftPower = manualLiftLeft && manualUp ? 75 : manualLiftLeft && manualDown ? -75 : manualLiftMode ? 0 : leftLiftPower;

	motor[liftRight] = rightLiftPower;
	motor[liftLeft] = leftLiftPower;

	if (rightIsDown)
	{
		SensorValue[QEncR] = 0;
	}
	if(leftIsDown)
	{
		SensorValue[QEncL] = 0;
	}
}

void intake()
{
		int motorpower = (vexRT[Btn6U] == 1) ? -100 : (vexRT[Btn6D] == 1) ? 100 : 0;
		motor[intake1] = motorpower;
}
