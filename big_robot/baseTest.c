#pragma config(UART_Usage, UART1, uartVEXLCD, baudRate19200, IOPins, None, None)
#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    lineFollower,   sensorLineFollower)
#pragma config(Sensor, in8,    gyro,           sensorGyro)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port1,           leftBack,      tmotorVex393_HBridge, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port2,           leftCenter,    tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           leftFront,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           ramp,          tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           leftShooter,   tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           rightShooter,  tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           intake,        tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           rightFront,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           rightCenter,   tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          rightBack,     tmotorVex393_HBridge, openLoop, reversed, encoderPort, I2C_2)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*
#pragma config(Sensor, dgtl1,  rightDriveEnc,  sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  leftDriveEnc,   sensorQuadEncoder)
#pragma config(Sensor, dgtl7,  leftDriveEnc2,  sensorQuadEncoder)
#pragma config(Sensor, dgtl10, rightDriveEnc2, sensorQuadEncoder)
*/

//VEX stuff
#pragma competitionControl(Competition)
#pragma autonomousDuration(60)
#pragma userControlDuration(60)

#include "Vex_Competition_Includes.c"

#define PI 3.1415
#define DEADZONE 15
#define MAXSPEED 120
#define MINSPEED 0

#define NearShot 50
#define FarShot  95

int shootSpeed = MINSPEED;
int shootMode = 0;
int DriveMode = -1;
bool isSwitchingModes = false;
bool isSwitchingSpeeds = false;

//Sturctures
////////////////////////////////////////////////////////////////////////////////////
typedef struct robot
{
  /* Struct to hold robots x, y, and theta relative to a starting position */
  float currX, currY;
  float prevX, prevY;  /* Keep prev data for PID purposes although not used yet */
  float currTheta, prevTheta;
  float turretAngle;
}robot;

typedef struct encoder
{
  /* Struct to hold encoder information and address */
  int currTick;
  int prevTick;
  float gearRatio;
  float gearEfficiency;
}encoder;

typedef struct Gyroscope
{
	int currReading;
	int prevReading;
	int cummulativeDrift;
	float driftConstant;
}Gyroscope;

/*  Movement types
//////////////////////////////////////////////////////////////////////
Planning on adding movements
for holonomic drive
                    */

const int	Forward = 11;
const int  Reverse = -11;
//const int  TurnLeft = 9;
//const int  TurnRight = -9;
//const int  Stop = 10;

//////////////////////////////////////////////////////////////////////

//Mapping Tasks and Methods
/*
  Mapping will be using an x,y, theta system
  The initial start of the vehicle will determine
  the x direction with the reference angle along
  the x axis, perpendicular to this will be the
  y axis. The initial position will be measured
  and after this the position will be updated.
  Currently the method of updating will be through
  gyroscope and drive encoders
*/

task updatePosition();
void zeroOutSensors();
int average(float value1, float value2);
int getTicks();
void initializeSturctures(robot *pos, encoder *left, encoder *right, Gyroscope *scope);
float ticksToCm(int ticks);

//Initialize structures
//////////////////////////////////////////////////////////////////////

/*  Initialize robot position  */
struct robot bigBot;


/*  Initialize encoders  */
struct encoder leftEnc, rightEnc;

/*  Initialize gyroscope */
struct Gyroscope gyroscope;

//////////////////////////////////////////////////////////////////////

void zeroOutSensors()
{
  SensorValue[gyro] = 0;
  nMotorEncoder[leftBack] = 0;
  nMotorEncoder[rightBack] = 0;
  //SensorValue[leftDriveEnc] = 0;
  //SensorValue[rightDriveEnc] = 0;
}

//////////////////////////////////////////////////////////////////////

void initializeSturctures(robot *pos, encoder *left, encoder *right, Gyroscope *scope)
{
	pos->currX = 0;
	pos->currY = 0;
	pos->prevX = 0;
	pos->prevY = 0;
	pos->currTheta = 0;
	pos->prevTheta = 0;

	left->currTick = 0;
	left->prevTick = 0;
	left->gearRatio = 1;
	left->gearEfficiency = 0.81;

	right->currTick = 0;
	right->prevTick = 0;
	right->gearRatio = 1;
	right->gearEfficiency = 0.81;

	scope->currReading = 0;
	scope->prevReading = 0;

	scope->cummulativeDrift = 0;
	scope->driftConstant = 1;

}

//////////////////////////////////////////////////////////////////////

task updatePosition()
{
  /*
    Use movement type to define how to get distance
    Use gyro to define the angle
    Create vector and add to original values
   */

  while(true){
    leftEnc.currTick = nMotorEncoder[leftBack];  //(SensorValue[leftDriveEnc] + SensorValue[leftDriveEnc2]) / 2;
    rightEnc.currTick = nMotorEncoder[rightBack]; //(SensorValue[rightDriveEnc] + SensorValue[rightDriveEnc]) / 2;


    int distance = ticksToCm(getTicks());//Get distance

		bigBot.currTheta = SensorValue[gyro] / 10. * PI / 180.;//Get angle

		bigBot.currX +=  cos(bigBot.currTheta) * distance;
		bigBot.currY +=  sin(bigBot.currTheta) * distance;

		clearLCDLine(0);
		clearLCDLine(1);
		char angle[20];
		sprintf(angle, "Angle: %.5f", bigBot.currTheta);
		displayLCDCenteredString(1, angle);

		char position[20];
		sprintf(position, "%.2f,%.2f",bigBot.currX, bigBot.currY);
		displayLCDCenteredString(0, position);

		time1[T3] = 0;

    while(time1[T3] < 200){} /*  Wait for 100 miliseconds to update */

    bigBot.prevTheta = bigBot.currTheta;
    leftEnc.prevTick = leftEnc.currTick;
    rightEnc.prevTick = rightEnc.currTick;
  }
}

//////////////////////////////////////////////////////////////////////

int getTicks()
{

  int driveConfig  =  (sgn(nMotorEncoder[leftBack]) * 10 - sgn(nMotorEncoder[rightBack]));//(sgn(motor[leftDriveEnc]) * 10 - sgn(motor[rightDriveEnc]));

	if(driveConfig == Forward || driveConfig == Reverse){
    return average((leftEnc.currTick - leftEnc.prevTick), (rightEnc.currTick - rightEnc.prevTick));
  }
  else //if(driveConfig == TurnLeft || driveConfig == TurnRight || driveConfig == Stop)
  {
    return 0; /* Only angle should change unless stopped */
  }

}

//////////////////////////////////////////////////////////////////////

int average(float value1, float value2)
{
  return (value1 + value2) / 2.;
}

//////////////////////////////////////////////////////////////////////

float ticksToCm(int ticks)
{
		return 2. * PI * (5.1) * (float)(ticks) / 360.;
}
//////////////////////////////////////////////////////////////////////

void drive()
{

	if(vexRT[Btn7L] && !isSwitchingModes)//change modes
	{

			DriveMode = -DriveMode;
			isSwitchingModes = true;
	}
	else if(vexRT[Btn7L] == 0)
	{
			isSwitchingModes = false;
	}

	if(DriveMode == 1) //arcade drive
	{
		int y = abs(vexRT[Ch3]) < DEADZONE ? 0 : vexRT[Ch3];
		int x = abs(vexRT[Ch1]) < DEADZONE ? 0 : vexRT[Ch1];

		motor[leftBack] = y + x;
		motor[leftCenter] = y + x;
		motor[leftFront] = y + x;

		motor[rightBack] = y - x;
		motor[rightCenter] = y - x;
		motor[rightFront] = y - x;


	}
	else if(DriveMode == -1) //tank drive
	{
		int rightPower = abs(vexRT[Ch2]) < DEADZONE ? 0 : vexRT[Ch2];
		int leftPower  = abs(vexRT[Ch3]) < DEADZONE ? 0 : vexRT[Ch3];

		motor[leftBack] = leftPower;
		motor[leftCenter] = leftPower;
		motor[leftFront] = leftPower;

		motor[rightBack] = rightPower;
		motor[rightCenter] = rightPower;
		motor[rightFront] = rightPower;
	}
}

////////////////////////////////////////////////////////////////////////////////////

void ctrl_intake()
{
	int power_in = vexRT[Btn5U] ? 127 : vexRT[Btn5D] ? -127 : 0;

	motor[intake] = power_in;

}

////////////////////////////////////////////////////////////////////////////////////

void ctrl_shooter()
{
	/*
	if(vexRT[Btn6D] == 1)
	{
		shootMode = 0;
	}
	else if(vexRT[Btn8U] == 1)
	{
		shootMode = 1;
	}
	else if(vexRT[Btn8D] == 1)
	{
		shootMode = 2;
	}

	shootSpeed = shootMode == 0 ? 0 : shootMode == 1 ? 95 : shootMode == 2 ? 57 : 0;
	*/

	if(vexRT[Btn6D] && !isSwitchingSpeeds)
	{
		shootSpeed += 5;
		isSwitchingSpeeds = true;
	}
	else if(vexRT[Btn6U] && !isSwitchingSpeeds)
	{
		shootSpeed -= 5;
		isSwitchingSpeeds = true;
	}
	else if(vexRT[Btn8D])
	{
		shootSpeed = 0;
	}
	else if(vexRT[Btn8U])
	{
		shootSpeed = 60;
	}

	if(!vexRT[Btn6U] && !vexRT[Btn6D])
	{
		isSwitchingSpeeds = false;
	}
	motor[leftShooter] = shootSpeed;
	motor[rightShooter] = shootSpeed;
}
////////////////////////////////////////////////////////////////////////////////////

void ctrl_ramp()
{
	int power_in = vexRT[Btn7U] ? 127 : vexRT[Btn7D] ? -127 : 0;

	motor[ramp] = power_in;

}

//Main Code
//////////////////////////////////////////////////////////////////////////////////////

/* Pre Auton */
void pre_auton(){
	zeroOutSensors();
}

/*                          Autonomous                            */
/*________________________________________________________________*/

task autonomous(){


}

/*                          UserControl                           */
/*________________________________________________________________*/

task usercontrol()
{

	initializeSturctures(bigBot, leftEnc, rightEnc, gyroscope);
  startTask(updatePosition);
	bLCDBacklight = true;

  while(true)
    {
    	ctrl_intake();
    	ctrl_shooter();
    	ctrl_ramp();

    	drive();
    }
}

//////////////////////////////////////////////////////////////////////////////////////////////////
