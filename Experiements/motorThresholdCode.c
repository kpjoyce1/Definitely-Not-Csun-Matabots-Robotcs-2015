#pragma config(UART_Usage, UART1, uartVEXLCD, baudRate19200, IOPins, None, None)
#pragma config(Sensor, in8,    gyro,           sensorGyro)
#pragma config(Sensor, dgtl10, rightDriveEnc,  sensorQuadEncoder)
#pragma config(Motor,  port2,           motorPin,    tmotorVex393_MC29, openLoop)

//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
task main()
{
//*************DETERMINING MOTOR THRESHOLD VALUES**************
// This code is designed to find the value necessary to get the vex motor to start moving
//
// The First section of code:
// The forward motor threshold is to be determined by incrementing the motor power
// until the encoder registers movement. Then the value will be decremented until no movement is
// registered, this will be the final threshold value saved. The forwardTime will also be saved
// which is the time it took the motor to move.
//
// The Second section of code:
// Same as the first section, however we are looking for the reverse threshold rather than the forward.
// Reverse time will also be found.
//
// The Third section of code:
// All results will be displayed on the LCD screen attached to the cortex. If a faulty motor
// if found, it will be displayed.
//
// It is important to note that the threshold value is dependent on weight applied to the motor shaft,
// therefore assuming the robot weight is distributed equally on all four wheels
// each motor must be tested by itself (off the robot) with weight = robot weight/4
// if accurate threshold values are to be determined


// motorPin, encoderPin are to be assigned a numerical pin value
int  motorForwardThreshold, motorReverseThreshold, forwardTime, reverseTime;
int i;

// START UP *********************************

clearLCDLine(0);
clearLCDLine(1);
displayLCDCenteredString(0, "VEX...");
displayLCDCenteredString(1, "Fuck Yeah..");

motor[motorPin] = 20;

wait1Msec(2000);

// FIRST SECTION OF CODE

SensorValue[rightDriveEnc] = 0;// Reset SensorValue to zero
 	bLCDBacklight = true; // LCD light is always on

	for(i=1;i<127;i++)	//This for-loop determines the forward motor threshold
	{
		time1[T1] = 0;
		motor[motorPin] = i;

		if ( abs(SensorValue[rightDriveEnc]) > 10)
		{
				forwardTime = time1(T1);
				motorForwardThreshold = i;
				break;          // Exit the loop
		}

		while( time1(T1) < 300)		  // Allow 300ms for the motor to move
		{
			if ( abs(SensorValue[rightDriveEnc]) > 10)
			{
				forwardTime = time1(T1);
				motorForwardThreshold = i;
				break;          // Exit the loop
			}
		}

	}
		motor[motorPin] = 0;			// Stop the motor
				clearLCDLine(0);
				clearLCDLine(1);
				char motorThresh[20];
				sprintf(motorThresh, "ForwardThesh: %d", motorForwardThreshold);
				displayLCDCenteredString(0, motorThresh);
				//displayLCDCenteredString(1, motorForwardThreshold);
				wait1Msec(3500);

	motor[motorPin] = 0;			// Stop the motor
	wait1Msec(1500);			//Pause 500 milliseconds to let the robot hit equilibrium (at rest)
	SensorValue[rightDriveEnc] = 0; 		// Reset encoder value

	for ( i = motorForwardThreshold - 1; i>0;i--) // This for-loop is used to find the actual threshold
												   // where the motor is on the verge of moving
	{
		motor[motorPin] = i;
		clearTimer(T1);
		while(time1(T1) < 300)		// see if the motor will respond in a short time frame
		{
			if( SensorValue[rightDriveEnc] == 0) // if the motor does not move this is the desired threshold
			{
					i = motorForwardThreshold;  // store i as threshold value
			}
			else 	// if the motor does move then wait for the next iteration
			{
					// Do nothing and wait for the timer to reach 300ms
			}
		}
		if( SensorValue[rightDriveEnc] == 0)     // If the motor did not move then we must exit the for-loop
		{
			i = 0; //Exit the for-loop
		}
	}
	motor[motorPin] = 0; // Turn the motor off
	wait1Msec(500);			 // Pause 500 milliseconds to let the robot hit equilibrium (at rest)


	// SECOND SECTION OF CODE

SensorValue[rightDriveEnc] = 0; // Reset SensorValue to zero

	for(i=-1;i>-127;i--)	//This for-loop determines the reverse motor threshold
	{
		clearTimer(T1);
		motor[motorPin] = i;
		while( time1(T1) < 300)		  // Allow 300ms for the motor to move
		{
			if ( SensorValue[rightDriveEnc] != 0)
			{
				time1(T1) = reverseTime;
				motorReverseThreshold = i;
				i = -128;          // Exit the loop because -128 is beyond the for-loops iteration
			}
		}
	}
	motor[motorPin] = 0;			// Stop the motor
	wait1Msec(500);						//Pause 500 milliseconds to let the robot hit equilibrium (at rest)
	SensorValue[rightDriveEnc] = 0; 	// Reset encoder value

	for ( i = motorReverseThreshold + 1; i<0 ; i++) // This for-loop is used to find the actual threshold
							// where the motor is on the verge of moving
	{
		motor[motorPin] = i;
		clearTimer(T1);
		while(time1(T1) < 300)		// see if the motor will respond in a short time frame
		{
			if( SensorValue[rightDriveEnc] == 0) // if the motor does not move this is the desired threshold
			{
					i = motorReverseThreshold;  // store i as threshold value
			}
			else 	// if the motor does move then wait for the next iteration
			{
					// Do nothing and wait for the timer to reach 300ms
			}
		}
		if( SensorValue[rightDriveEnc] == 0) // If the motor did not move then we must exit the for-loop
		{
			i = 0; //Exit the for-loop
		}
	}
	motor[motorPin] = 0; // Turn the motor off
	wait1Msec(500);			 // Pause 500 milliseconds to let the robot hit equilibrium (at rest)

// THIRD SECTION OF CODE

	while(true)
	{
		if ( motorForwardThreshold < 70 && motorReverseThreshold > -70 ) // anything past this boundary (arbitrarily)
			{							// means the motor is faulty
										// Forward threshold information
				char motorThresh[20];
				sprintf(motorThresh, "ForwardThesh: %d", motorForwardThreshold);
				displayLCDCenteredString(0, motorThresh);
				//displayLCDCenteredString(1, motorForwardThreshold);
				wait1Msec(3500);

				char _forwardTime[20];
				sprintf(_forwardTime, "ForwardTime: %d", forwardTime);
				displayLCDCenteredString(1, _forwardTime);
				wait1Msec(3500);

				// Reverse threshold information
				clearLCDLine(0);
				clearLCDLine(1);
				char _reverseThresh[20];
				sprintf(_reverseThresh,"RevThresh: %d", motorReverseThreshold);
				displayLCDCenteredString(1, _reverseThresh);
				wait1Msec(3500);
				clearLCDLine(0);
				clearLCDLine(1);
				char _reverseTime[20];
				sprintf(_reverseTime, "RevTime: %d", reverseTime);
				displayLCDCenteredString(0, _reverseTime);
				//displayLCDCenteredString(1, reverseTime);
				wait1Msec(3500);
			}
			else
			{
				clearLCDLine(0);
				clearLCDLine(1);
				displayLCDCenteredString(0, "FAULTY");
				displayLCDCenteredString(1, "MOTOR");
				wait1Msec(1000);
			}
	}
}
